# 需求分析

## 背景分析

为了提升小型餐馆的日常运营效率、降低管理成本，本系统旨在实现对餐馆核心业务流程的数字化管理，包括**菜品管理、餐桌管理、堂食与外卖订单处理、原材料管理、费用核算、用户权限控制和运营统计**等功能。

目标用户包括餐馆**管理员、服务员、后厨人员及顾客**，前端使用 **Flutter** 构建移动界面，后端使用 **Go** 提供服务与数据库接口。

## 系统目标

1. 支持餐馆日常运营相关的数据录入、更新和查询；
2. 实现订单全流程管理（堂食）；
3. 提供食材库存与成本控制功能；
4. 管理固定和变动运营费用；
5. 提供实时销售与利润统计；
6. 实现权限分级管理，保障系统数据安全；
7. 系统应具备良好的响应速度和错误处理机制。

## 功能需求

#### **1. 菜品管理模块**

- 添加/修改/删除菜品；
- 设置价格、分类、图片、可售状态；
- 建立菜品与原材料的消耗关系。

#### **2. 餐桌管理模块**

- 增删改查餐桌信息；
- 表示餐桌状态（空闲、占用、预定）；
- 支持堂食订单关联桌号。

#### **3. 堂食管理模块**

- 创建点餐订单；
- 修改订单状态（待做、制作中、上菜、结账）；
- 生成账单、打印功能（可选）。

#### **4. 外卖管理模块**

- 创建外卖订单，填写送达地址；
- 配送状态追踪；
- 计算并记录配送费用。

#### **5. 原材料管理模块**

- 原材料库存增减（采购、消耗）；
- 库存预警；
- 与菜品消耗挂钩，自动扣减。

#### **6. 费用管理模块**

- 输入人工费、水电费、管理费等；
- 支持按月、季度、年统计；
- 与营业额配合，计算利润。

#### **7. 查询与统计模块**

- 日/周/月销售数据图表；
- 菜品销售排行；
- 原材料消耗统计；
- 营业利润报表。

#### **8. 用户权限模块**

- 用户注册、登录、权限设定；
- 支持不同角色访问不同功能模块。

#### **9. 异常与日志处理**

- 输入数据校验；
- 业务状态判断（如库存不足）；
- 后端接口异常提示；
- 操作日志记录（可选）。

## 非功能需求

- **性能**：响应时间 < 500ms；
- **可靠性**：高可用设计，关键数据操作有反馈；
- **安全性**：权限控制、登录认证、输入校验；
- **可维护性**：模块化设计、接口文档齐全；
- **兼容性**：支持 Android/iOS 移动端运行，有余力可以支持桌面端运行；
- **可扩展性**：支持后续新增顾客点餐端口或扫码点单功能。

## 用户角色分析

| **角色** | **权限描述**                     |
| -------- | -------------------------------- |
| 管理员   | 管理菜品、桌位、用户、费用、权限 |
| 服务员   | 创建/处理堂食订单                |
| 后厨人员 | 查看待处理订单、变更状态         |

# 技术选型

随着移动平台的逐渐兴起，桌面端的管理系统灵活性和便携性显著降低，取而代之的是手机和平板APP这类可移动使用的应用程序。

所以本系统的前端页面拟采用Flutter框架（Dart语言）进行跨平台开发，Flutter有两点优势，其一是强大的跨平台性，几乎无需额外适配即可做到一次编写，到处运行；其二是其对不同尺寸屏幕的良好适配，考虑到本系统的实际使用场景可能是在餐馆的点餐平板上，所以使用Flutter可以很容易写出同时适配平板这类大屏设备的应用。

后端则采用Go语言开发，使用Gin作为后端框架，原因是Go相比传统的Java开发，周期更短，适合快速迭代，并且在性能上也要显著优于Java。从语言方面，Go的语言也要比Java简洁不少，能大大提高开发效率。而Gin框架也有着丰富的后端功能，例如拦截器、网关、各种中间件等，生态方面也比较成熟，很多问题都有现成且成熟的解决方案。

值得一提的是，本项目的网路请求不会使用传统的JSON来传输数据，而是使用Google的Protocol Buffers（简称Protobuf）协议来进行数据的传输。之所以选择Protobuf，原因如下：

- Protobuf支持各种编程语言的代码生成，无需手动处理数据对象的序列化和反序列化，直接使用生成的代码即可，protoc原生编译器即支持Go语言，配合插件使用，能做到支持Dart语言，能够适应现有技术栈。只需写一个随项目编译同步运行的protoc脚本，即可快速生成数据对象的序列化和反序列化代码，能大大提高开发效率，减少错误。
- Protobuf是通过二进制传输数据对象，采用了一种紧凑的二进制格式，相比JSON要快很多，适合用于移动端这样需要节省资源的场景。
- Protobuf是目前企业级项目的标准配置，有丰富的插件，生态成熟，可以拓展各种功能。

# 数据库设计

表类型如下：

```
/// 以下是实体表
role_types(
	id*,
	name
)

employees(
	id*,
	name,
	phone,
	salary, // 工资
	role_type // 员工角色, role_types表外键
)

orders(
	id*,
	address, // 送货地址, 堂食类型为null
	datetime,
	occupy_status, // 餐桌占领状态, 仅堂食
	discount, // 折扣信息
	type // 堂食或者外卖
)

customers(
	id*,
	account*, // 账号, 唯一且展示给用户, 类型字符串
	nickname,
	phone
)

private_rooms(
	id*,
	name*, // 包间名称, 唯一，比如什么111、八仙过海之类的包间名称
	position, // 包间位置(几区几楼什么的)
	type, // 包间类型, 分为共享类型和全包类型, 全包类型必须由一个顾客包下其中的全部餐桌, 而不能和其他客户共享
	occupy_status // 包间的占领状态
)

dining_tables( // 餐桌
	id*,
	number*, // 桌号, 唯一, 显示给用户
	type, // 桌子类型, 包含可坐人数, 桌子形状等信息, 用于APP端绘制桌子图像
	occupy_status, // 桌子的占领状态, 空闲、部分占领、全部占领
	room // 属于哪个private_room
)

seats( // 餐桌座位
	id*,
	number,
	occupy_status, // 占领状态, 空闲 or 被占
	table // 属于哪个dining_table
)

materials( // 原料
	id*,
	price,
	count,
	name
)

dishes( // 菜品
	id*,
	name*, // 菜名, 唯一
	sell_status, // 销售状态, 在售、下架、售罄等等
)

/// 以下是关系表
manage(
	manager_id*: one,
	employee_id: many*
)

dish_material_consume( // 菜品消耗的食材
	dish*: many,
	material*: many,
	count // 消耗的数量
)

order_dish(
	order*: many,
	dish*: many,
	discount
)

deliver_takeout( // 送外卖
	order*: many,
	rider*: one,
	start_datetime,
	end_datetime,
	estimated_datetime // 预估送达时间
)

place_order( // 顾客下订单
	customer*: one,
	order*: many,
)

order_room_use( // 订单与被使用的包间
	room*: one,
	order*: many,
)

order_table_use( // 订单与被使用的餐桌, 订单和餐桌是一对一关系
	table_id*: one,
	order_id*: one
)

order_banquet( // 吃席模式, 所有桌菜品全部一致, 共享同一个订单, 原订单为host_order, 自动生成子订单
	host_order*: one, // 主订单
	order*: many // 从属订单, 优惠等跟随主订单
)

room_table_arr( // 房间和餐桌
	room*: one,
	table*: many
)

table_seat_arr( // 餐桌和座位
	table*: one,
	seat*: many,
)
```



